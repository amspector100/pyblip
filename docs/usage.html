<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tutorials &mdash; pyblip 0.3.0 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="API Reference" href="apiref.html" />
    <link rel="prev" title="Getting Started" href="installation.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> pyblip
          </a>
              <div class="version">
                0.3.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="installation.html">Getting Started</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Tutorials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#1.-Introduction">1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#2.-Variable-selection">2. Variable selection</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#2.1-Generating-synthetic-data">2.1 Generating synthetic data</a></li>
<li class="toctree-l3"><a class="reference internal" href="#2.2-Linear-Spike-and-Slab-model-+-BLiP">2.2 Linear Spike-and-Slab model + BLiP</a></li>
<li class="toctree-l3"><a class="reference internal" href="#2.3-SuSiE-+-BLiP">2.3 SuSiE + BLiP</a></li>
<li class="toctree-l3"><a class="reference internal" href="#2.4-Probit-spike-and-slab-model-+-BLiP">2.4 Probit spike-and-slab model + BLiP</a></li>
<li class="toctree-l3"><a class="reference internal" href="#2.5-Hierarchical-priors-to-ensure-error-control">2.5 Hierarchical priors to ensure error control</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#3.-Changepoint-detection">3. Changepoint detection</a></li>
<li class="toctree-l2"><a class="reference internal" href="#4.-Point-source-detection">4. Point-source detection</a></li>
<li class="toctree-l2"><a class="reference internal" href="#5.-Inputs-for-arbitrary-problems">5. Inputs for arbitrary problems</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#5.1-Posterior-samples-for-discrete-problems">5.1 Posterior samples for discrete problems</a></li>
<li class="toctree-l3"><a class="reference internal" href="#5.2-Posterior-samples-for-continuous-problems">5.2 Posterior samples for continuous problems</a></li>
<li class="toctree-l3"><a class="reference internal" href="#5.3-Advanced-usage:-directly-specifying-candidate-groups">5.3 Advanced usage: directly specifying candidate groups</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="apiref.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/amspector100/pyblip">pyblip source</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/amspector100/blipr">blipr source</a></li>
<li class="toctree-l1"><a class="reference external" href="https://arxiv.org/abs/2203.17208">BLiP paper (arXiv)</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pyblip</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Tutorials</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/usage.ipynb.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS for nbsphinx extension */

/* remove conflicting styling from Sphinx themes */
div.nbinput.container div.prompt *,
div.nboutput.container div.prompt *,
div.nbinput.container div.input_area pre,
div.nboutput.container div.output_area pre,
div.nbinput.container div.input_area .highlight,
div.nboutput.container div.output_area .highlight {
    border: none;
    padding: 0;
    margin: 0;
    box-shadow: none;
}

div.nbinput.container > div[class*=highlight],
div.nboutput.container > div[class*=highlight] {
    margin: 0;
}

div.nbinput.container div.prompt *,
div.nboutput.container div.prompt * {
    background: none;
}

div.nboutput.container div.output_area .highlight,
div.nboutput.container div.output_area pre {
    background: unset;
}

div.nboutput.container div.output_area div.highlight {
    color: unset;  /* override Pygments text color */
}

/* avoid gaps between output lines */
div.nboutput.container div[class*=highlight] pre {
    line-height: normal;
}

/* input/output containers */
div.nbinput.container,
div.nboutput.container {
    display: -webkit-flex;
    display: flex;
    align-items: flex-start;
    margin: 0;
    width: 100%;
}
@media (max-width: 540px) {
    div.nbinput.container,
    div.nboutput.container {
        flex-direction: column;
    }
}

/* input container */
div.nbinput.container {
    padding-top: 5px;
}

/* last container */
div.nblast.container {
    padding-bottom: 5px;
}

/* input prompt */
div.nbinput.container div.prompt pre {
    color: #307FC1;
}

/* output prompt */
div.nboutput.container div.prompt pre {
    color: #BF5B3D;
}

/* all prompts */
div.nbinput.container div.prompt,
div.nboutput.container div.prompt {
    width: 4.5ex;
    padding-top: 5px;
    position: relative;
    user-select: none;
}

div.nbinput.container div.prompt > div,
div.nboutput.container div.prompt > div {
    position: absolute;
    right: 0;
    margin-right: 0.3ex;
}

@media (max-width: 540px) {
    div.nbinput.container div.prompt,
    div.nboutput.container div.prompt {
        width: unset;
        text-align: left;
        padding: 0.4em;
    }
    div.nboutput.container div.prompt.empty {
        padding: 0;
    }

    div.nbinput.container div.prompt > div,
    div.nboutput.container div.prompt > div {
        position: unset;
    }
}

/* disable scrollbars on prompts */
div.nbinput.container div.prompt pre,
div.nboutput.container div.prompt pre {
    overflow: hidden;
}

/* input/output area */
div.nbinput.container div.input_area,
div.nboutput.container div.output_area {
    -webkit-flex: 1;
    flex: 1;
    overflow: auto;
}
@media (max-width: 540px) {
    div.nbinput.container div.input_area,
    div.nboutput.container div.output_area {
        width: 100%;
    }
}

/* input area */
div.nbinput.container div.input_area {
    border: 1px solid #e0e0e0;
    border-radius: 2px;
    /*background: #f5f5f5;*/
}

/* override MathJax center alignment in output cells */
div.nboutput.container div[class*=MathJax] {
    text-align: left !important;
}

/* override sphinx.ext.imgmath center alignment in output cells */
div.nboutput.container div.math p {
    text-align: left;
}

/* standard error */
div.nboutput.container div.output_area.stderr {
    background: #fdd;
}

/* ANSI colors */
.ansi-black-fg { color: #3E424D; }
.ansi-black-bg { background-color: #3E424D; }
.ansi-black-intense-fg { color: #282C36; }
.ansi-black-intense-bg { background-color: #282C36; }
.ansi-red-fg { color: #E75C58; }
.ansi-red-bg { background-color: #E75C58; }
.ansi-red-intense-fg { color: #B22B31; }
.ansi-red-intense-bg { background-color: #B22B31; }
.ansi-green-fg { color: #00A250; }
.ansi-green-bg { background-color: #00A250; }
.ansi-green-intense-fg { color: #007427; }
.ansi-green-intense-bg { background-color: #007427; }
.ansi-yellow-fg { color: #DDB62B; }
.ansi-yellow-bg { background-color: #DDB62B; }
.ansi-yellow-intense-fg { color: #B27D12; }
.ansi-yellow-intense-bg { background-color: #B27D12; }
.ansi-blue-fg { color: #208FFB; }
.ansi-blue-bg { background-color: #208FFB; }
.ansi-blue-intense-fg { color: #0065CA; }
.ansi-blue-intense-bg { background-color: #0065CA; }
.ansi-magenta-fg { color: #D160C4; }
.ansi-magenta-bg { background-color: #D160C4; }
.ansi-magenta-intense-fg { color: #A03196; }
.ansi-magenta-intense-bg { background-color: #A03196; }
.ansi-cyan-fg { color: #60C6C8; }
.ansi-cyan-bg { background-color: #60C6C8; }
.ansi-cyan-intense-fg { color: #258F8F; }
.ansi-cyan-intense-bg { background-color: #258F8F; }
.ansi-white-fg { color: #C5C1B4; }
.ansi-white-bg { background-color: #C5C1B4; }
.ansi-white-intense-fg { color: #A1A6B2; }
.ansi-white-intense-bg { background-color: #A1A6B2; }

.ansi-default-inverse-fg { color: #FFFFFF; }
.ansi-default-inverse-bg { background-color: #000000; }

.ansi-bold { font-weight: bold; }
.ansi-underline { text-decoration: underline; }


div.nbinput.container div.input_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight].math,
div.nboutput.container div.output_area.rendered_html,
div.nboutput.container div.output_area > div.output_javascript,
div.nboutput.container div.output_area:not(.rendered_html) > img{
    padding: 5px;
    margin: 0;
}

/* fix copybtn overflow problem in chromium (needed for 'sphinx_copybutton') */
div.nbinput.container div.input_area > div[class^='highlight'],
div.nboutput.container div.output_area > div[class^='highlight']{
    overflow-y: hidden;
}

/* hide copybtn icon on prompts (needed for 'sphinx_copybutton') */
.prompt .copybtn {
    display: none;
}

/* Some additional styling taken form the Jupyter notebook CSS */
div.rendered_html table {
  border: none;
  border-collapse: collapse;
  border-spacing: 0;
  color: black;
  font-size: 12px;
  table-layout: fixed;
}
div.rendered_html thead {
  border-bottom: 1px solid black;
  vertical-align: bottom;
}
div.rendered_html tr,
div.rendered_html th,
div.rendered_html td {
  text-align: right;
  vertical-align: middle;
  padding: 0.5em 0.5em;
  line-height: normal;
  white-space: normal;
  max-width: none;
  border: none;
}
div.rendered_html th {
  font-weight: bold;
}
div.rendered_html tbody tr:nth-child(odd) {
  background: #f5f5f5;
}
div.rendered_html tbody tr:hover {
  background: rgba(66, 165, 245, 0.2);
}

/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="Tutorials">
<h1>Tutorials<a class="headerlink" href="#Tutorials" title="Permalink to this headline"></a></h1>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">stats</span>

<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="kn">import</span> <span class="nn">pyblip</span>
</pre></div>
</div>
</div>
<div class="section" id="1.-Introduction">
<h2>1. Introduction<a class="headerlink" href="#1.-Introduction" title="Permalink to this headline"></a></h2>
<p>In many applications, we can tell that a signal of interest exists but cannot perfectly “localize” it. For example, when regressing an outcome <span class="math notranslate nohighlight">\(Y\)</span> on highly correlated covariates <span class="math notranslate nohighlight">\((X_1, X_2)\)</span>, the data may suggest that <em>at least</em> one of <span class="math notranslate nohighlight">\((X_1, X_2)\)</span> influences <span class="math notranslate nohighlight">\(Y\)</span>, but it may be challenging to tell which of <span class="math notranslate nohighlight">\((X_1, X_2)\)</span> is important. Likewise, in genetic fine-mapping, biologists may have high confidence that a gene influences a disease without knowing precisely
which genetic variants cause the disease. Similar problems arise in many settings with spatial or temporal structure, including change-point detection and astronomical point-source detection.</p>
<p><em>Bayesian Linear Programming</em> (BLiP) is a method which jointly detects as many signals as possible while localizing them as precisely as possible. BLiP can wrap on top of nearly any Bayesian model or algorithm, and it will return a set of regions which each contain at least one signal with high confidence. For example, in regression problems, BLiP might return the region <span class="math notranslate nohighlight">\((X_1, X_2)\)</span>, which suggests that at least one of <span class="math notranslate nohighlight">\((X_1, X_2)\)</span> is an important variable. BLiP controls the false
discovery rate while also making these regions as narrow as possible, meaning that (roughly speaking) it will perfectly localize signals whenever this is possible! See <a class="reference external" href="https://arxiv.org/abs/2203.17208">Spector and Janson (2022)</a> for more details.</p>
<p><code class="docutils literal notranslate"><span class="pre">pyblip</span></code> is an efficient python implementation of BLiP, which is designed so that BLiP can wrap on top of the Bayesian model in only one or two lines of code. Below, we give concrete examples of how to apply <code class="docutils literal notranslate"><span class="pre">pyblip</span></code> in three settings: variable selection, change-point detection, and point-source detection.</p>
</div>
<div class="section" id="2.-Variable-selection">
<h2>2. Variable selection<a class="headerlink" href="#2.-Variable-selection" title="Permalink to this headline"></a></h2>
<div class="section" id="2.1-Generating-synthetic-data">
<h3>2.1 Generating synthetic data<a class="headerlink" href="#2.1-Generating-synthetic-data" title="Permalink to this headline"></a></h3>
<p>Below, we generate synthetic data of highly correlated covariates <span class="math notranslate nohighlight">\(X = (X_1, \dots, X_p)\)</span> and a response <span class="math notranslate nohighlight">\(Y\)</span>.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># generate synthetic data with 10 signal variables</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">12345</span><span class="p">)</span>
<span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">beta</span> <span class="o">=</span> <span class="n">pyblip</span><span class="o">.</span><span class="n">utilities</span><span class="o">.</span><span class="n">generate_regression_data</span><span class="p">(</span>
    <span class="n">n</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">sparsity</span><span class="o">=</span><span class="mf">0.02</span><span class="p">,</span> <span class="n">dgp_seed</span><span class="o">=</span><span class="mi">12345</span>
<span class="p">)</span>
<span class="n">signal_variables</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">beta</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="c1"># X has strong local correlations</span>
<span class="n">sns</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;RdBu&#39;</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Correlation matrix for X&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="_images/usage_7_0.png" src="_images/usage_7_0.png" />
</div>
</div>
</div>
<div class="section" id="2.2-Linear-Spike-and-Slab-model-+-BLiP">
<h3>2.2 Linear Spike-and-Slab model + BLiP<a class="headerlink" href="#2.2-Linear-Spike-and-Slab-model-+-BLiP" title="Permalink to this headline"></a></h3>
<p>We can apply BLiP in two steps. First, we fit a Bayesian model to <span class="math notranslate nohighlight">\((X, Y)\)</span>—in this case, we use a spike-and-slab model for sparse linear regression. Second, we run BLiP directly on top of the posterior samples from the Bayesian model, as shown below.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Step 1: sample from Gaussian spike-and-slab model</span>
<span class="n">lm</span> <span class="o">=</span> <span class="n">pyblip</span><span class="o">.</span><span class="n">linear</span><span class="o">.</span><span class="n">LinearSpikeSlab</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>
<span class="n">lm</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span> <span class="n">chains</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">burn</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">bsize</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Step 2: Apply BLiP to detect signal variables</span>
<span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">detections</span> <span class="o">=</span> <span class="n">pyblip</span><span class="o">.</span><span class="n">blip</span><span class="o">.</span><span class="n">BLiP</span><span class="p">(</span>
    <span class="n">samples</span><span class="o">=</span><span class="n">lm</span><span class="o">.</span><span class="n">betas</span><span class="p">,</span>
    <span class="n">q</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
    <span class="n">error</span><span class="o">=</span><span class="s1">&#39;fdr&#39;</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">BLiP ran in </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="si">}</span><span class="s2"> seconds.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>

BLiP ran in 0.96 seconds.

</pre></div></div>
</div>
<p>Since the data is synthetic, we can check whether the results from BLiP are accurate.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The true signal variables are </span><span class="si">{</span><span class="n">signal_variables</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">detections</span><span class="p">:</span>
    <span class="n">true_detection</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">group</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">signal_variables</span><span class="p">)))</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">true_detection</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;BLiP correctly detected a signal variable in </span><span class="si">{</span><span class="n">x</span><span class="o">.</span><span class="n">group</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;BLiP incorrectly detected a signal variable in </span><span class="si">{</span><span class="n">x</span><span class="o">.</span><span class="n">group</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
The true signal variables are [ 54  68 148 184 272 306 383 409 426 471].
BLiP correctly detected a signal variable in {54}.
BLiP correctly detected a signal variable in {68}.
BLiP correctly detected a signal variable in {184}.
BLiP correctly detected a signal variable in {272}.
BLiP correctly detected a signal variable in {306}.
BLiP correctly detected a signal variable in {383}.
BLiP correctly detected a signal variable in {426}.
BLiP correctly detected a signal variable in {417, 421, 404, 407, 408, 409, 411, 412}.
</pre></div></div>
</div>
<p>As we can see, sometimes BLiP will detect individual signal variables, but often this is not possible due to the high correlations among <span class="math notranslate nohighlight">\(X\)</span>. In the latter case, BLiP outputs larger clusters of variables.</p>
</div>
<div class="section" id="2.3-SuSiE-+-BLiP">
<h3>2.3 SuSiE + BLiP<a class="headerlink" href="#2.3-SuSiE-+-BLiP" title="Permalink to this headline"></a></h3>
<p>BLiP can apply on top of nearly any Bayesian model or algorithm, including variational algorithms. Here, we show how to apply BLiP on top of a SuSiE model <a class="reference external" href="https://www.biorxiv.org/content/10.1101/501114v4">(Wang et al, 2020)</a>. We do this in three steps: Step 1 is to fit SuSiE, Step 2 is to create candidate groups based off of the SuSiE outputs, and Step 3 is to apply BLiP.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Step 1: Fit SuSiE model</span>
<span class="kn">import</span> <span class="nn">rpy2</span>
<span class="kn">import</span> <span class="nn">rpy2.robjects.numpy2ri</span> <span class="k">as</span> <span class="nn">numpy2ri</span>
<span class="kn">import</span> <span class="nn">rpy2.robjects</span> <span class="k">as</span> <span class="nn">ro</span>
<span class="kn">from</span> <span class="nn">rpy2.rinterface_lib.embedded</span> <span class="kn">import</span> <span class="n">RRuntimeError</span>
<span class="kn">from</span> <span class="nn">rpy2.robjects.packages</span> <span class="kn">import</span> <span class="n">importr</span>
<span class="o">%</span><span class="k">load_ext</span> rpy2.ipython

<span class="c1"># Import and run susie</span>
<span class="n">susieR</span> <span class="o">=</span> <span class="n">importr</span><span class="p">(</span><span class="s1">&#39;susieR&#39;</span><span class="p">)</span>
<span class="n">R_null</span> <span class="o">=</span> <span class="n">ro</span><span class="o">.</span><span class="n">rinterface</span><span class="o">.</span><span class="n">NULL</span>
<span class="n">numpy2ri</span><span class="o">.</span><span class="n">activate</span><span class="p">()</span>
<span class="n">susie_obj</span> <span class="o">=</span> <span class="n">susieR</span><span class="o">.</span><span class="n">susie</span><span class="p">(</span>
    <span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">coverage</span><span class="o">=</span><span class="mf">0.9</span>
<span class="p">)</span>
<span class="c1"># Extract output</span>
<span class="n">alphas</span> <span class="o">=</span> <span class="n">susie_obj</span><span class="o">.</span><span class="n">rx2</span><span class="p">(</span><span class="s1">&#39;alpha&#39;</span><span class="p">)</span>
<span class="n">susie_sets</span> <span class="o">=</span> <span class="n">susie_obj</span><span class="o">.</span><span class="n">rx2</span><span class="p">(</span><span class="s1">&#39;sets&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">susie_sets</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">susie_sets</span>
    <span class="p">]</span>
<span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
    <span class="n">susie_sets</span> <span class="o">=</span> <span class="p">[]</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
The rpy2.ipython extension is already loaded. To reload it, use:
  %reload_ext rpy2.ipython
</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Step 2: create candidate groups based off susie outputs</span>
<span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">cand_groups</span> <span class="o">=</span> <span class="n">pyblip</span><span class="o">.</span><span class="n">create_groups</span><span class="o">.</span><span class="n">susie_groups</span><span class="p">(</span>
    <span class="n">alphas</span><span class="o">=</span><span class="n">alphas</span><span class="p">,</span>
    <span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">,</span>
    <span class="n">q</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="c1"># FDR level</span>
<span class="p">)</span>
<span class="c1"># Step 3: run BLiP</span>
<span class="n">detections</span> <span class="o">=</span> <span class="n">pyblip</span><span class="o">.</span><span class="n">blip</span><span class="o">.</span><span class="n">BLiP</span><span class="p">(</span>
    <span class="n">cand_groups</span><span class="o">=</span><span class="n">cand_groups</span><span class="p">,</span>
    <span class="n">error</span><span class="o">=</span><span class="s1">&#39;fdr&#39;</span><span class="p">,</span>
    <span class="n">q</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">elapsed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Creating cand groups and running BLiP took </span><span class="si">{</span><span class="n">elapsed</span><span class="si">}</span><span class="s2"> seconds.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>

Creating cand groups and running BLiP took 0.34 seconds.

</pre></div></div>
</div>
<p>We can compare the detections from SuSiE and SuSiE + BLiP. As we can see from the smaller group size, SuSiE + BLiP localizes signals more precisely than SuSiE alone. (All detections are true detections in this case.)</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">susie_sets</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
[{68}, {306}, {426}, {184}, {272}, {54}, {382, 383, 384}]
</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">group</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">detections</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
[{54}, {68}, {184}, {272}, {306}, {383}, {426}]
</pre></div></div>
</div>
<p>As the number of signals increases, SuSiE + BLiP tends to have substantially higher power than SuSiE alone, as discussed in <a class="reference external" href="https://arxiv.org/abs/2203.17208">Spector and Janson (2022)</a>.</p>
</div>
<div class="section" id="2.4-Probit-spike-and-slab-model-+-BLiP">
<h3>2.4 Probit spike-and-slab model + BLiP<a class="headerlink" href="#2.4-Probit-spike-and-slab-model-+-BLiP" title="Permalink to this headline"></a></h3>
<p>We can run BLiP on top of nearly any regression model, including various models for binary responses. For example, suppose we only observe a binary indicator <span class="math notranslate nohighlight">\(Y^{\star}\)</span> as an outcome. We can apply BLiP directly on top of a sparse probit model in this setting, as shown below.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Step 1: fit probit model</span>
<span class="n">ystar</span> <span class="o">=</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span>
<span class="n">pm</span> <span class="o">=</span> <span class="n">pyblip</span><span class="o">.</span><span class="n">probit</span><span class="o">.</span><span class="n">ProbitSpikeSlab</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">ystar</span><span class="p">)</span>
<span class="n">pm</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">chains</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">bsize</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[17]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Step 2: apply BLiP to posterior samples</span>
<span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">detections</span> <span class="o">=</span> <span class="n">pyblip</span><span class="o">.</span><span class="n">blip</span><span class="o">.</span><span class="n">BLiP</span><span class="p">(</span>
    <span class="n">samples</span><span class="o">=</span><span class="n">pm</span><span class="o">.</span><span class="n">betas</span><span class="p">,</span>
    <span class="n">q</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
    <span class="n">error</span><span class="o">=</span><span class="s1">&#39;fdr&#39;</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">BLiP ran in </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="si">}</span><span class="s2"> seconds.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>

BLiP ran in 0.58 seconds.
Long-step dual simplex will be used

</pre></div></div>
</div>
<p>Once again, we can check that BLiP makes (mostly) correct detections:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[20]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The true signal variables are </span><span class="si">{</span><span class="n">signal_variables</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">detections</span><span class="p">:</span>
    <span class="n">true_detection</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">group</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">signal_variables</span><span class="p">)))</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">true_detection</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;BLiP correctly detected a signal variable in </span><span class="si">{</span><span class="n">x</span><span class="o">.</span><span class="n">group</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;BLiP incorrectly detected a signal variable in </span><span class="si">{</span><span class="n">x</span><span class="o">.</span><span class="n">group</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
The true signal variables are [ 54  68 148 184 272 306 383 409 426 471].
BLiP correctly detected a signal variable in {68}.
BLiP correctly detected a signal variable in {424, 426}.
BLiP correctly detected a signal variable in {177, 180, 181, 184, 185}.
BLiP correctly detected a signal variable in {263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274}.
BLiP correctly detected a signal variable in {313, 306, 308}.
BLiP incorrectly detected a signal variable in {58, 53}.
BLiP correctly detected a signal variable in {59, 54}.
BLiP correctly detected a signal variable in {398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422}.
</pre></div></div>
</div>
</div>
<div class="section" id="2.5-Hierarchical-priors-to-ensure-error-control">
<h3>2.5 Hierarchical priors to ensure error control<a class="headerlink" href="#2.5-Hierarchical-priors-to-ensure-error-control" title="Permalink to this headline"></a></h3>
<p>BLiP can wrap on top of nearly any Bayesian model, and in practice, it is fairly robust to some degree of model misspecification (see <a class="reference external" href="https://arxiv.org/abs/2203.17208">Spector and Janson (2022)</a> for simulations and a discussion of this issue). That said, if the underlying model is extremely poorly specified, BLiP will violate FDR control. For example, in the following problem, the prior indicates that <span class="math notranslate nohighlight">\(50\%\)</span> of the variables are signal variables, whereas in truth only <span class="math notranslate nohighlight">\(4\%\)</span> of
the variables are signal variables.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Sample from an obviously bad spike and slab model</span>
<span class="n">lm_bad</span> <span class="o">=</span> <span class="n">pyblip</span><span class="o">.</span><span class="n">linear</span><span class="o">.</span><span class="n">LinearSpikeSlab</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">p0</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">update_p0</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">lm_bad</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span> <span class="n">chains</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">burn</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">bsize</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># run blip: FDR control fails because the model is very badly mispecified</span>
<span class="n">detections</span> <span class="o">=</span> <span class="n">pyblip</span><span class="o">.</span><span class="n">blip</span><span class="o">.</span><span class="n">BLiP</span><span class="p">(</span>
    <span class="n">samples</span><span class="o">=</span><span class="n">lm_bad</span><span class="o">.</span><span class="n">betas</span><span class="p">,</span>
    <span class="n">error</span><span class="o">=</span><span class="s1">&#39;fdr&#39;</span><span class="p">,</span>
    <span class="n">q</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
    <span class="n">max_pep</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
<span class="n">sigvars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">signal_variables</span><span class="p">)</span>
<span class="n">fdp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span>
    <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">group</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">sigvars</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">detections</span><span class="p">]</span>
<span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The false positive rate is </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="mi">100</span><span class="o">*</span><span class="n">fdp</span><span class="p">)</span><span class="si">}</span><span class="s2">% due to the mispecified model!</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
BLiP problem has 2263 groups in contention, with 500 active features/locations
</pre></div></div>
</div>
<p>To avoid this situation, we recommend using <strong>hierarchical priors</strong> on unknown nuisance parameters like the sparsity level in regression problems, with a conservative choice of hyperparameters. The samplers in <code class="docutils literal notranslate"><span class="pre">pyblip</span></code> automatically use relatively uninformative hierarchical priors which empirically control the FDR well in a variety of settings. For example, in the previous examples, the prior was quite uninformative, and BLiP still performed quite well.</p>
<p>When using MCMC algorithms, we also recommend <strong>running multiple MCMC chains</strong> with different initializations to protect against convergence issues. As discussed in <a class="reference external" href="https://arxiv.org/abs/2203.17208">Spector and Janson (2022)</a>, even when each individual MCMC chain fails to converge, often using multiple chains will overstate the uncertainty in the location of signals, leading to conservative but valid inference.</p>
</div>
</div>
<div class="section" id="3.-Changepoint-detection">
<h2>3. Changepoint detection<a class="headerlink" href="#3.-Changepoint-detection" title="Permalink to this headline"></a></h2>
<p>Given time series data <span class="math notranslate nohighlight">\((Y_1, \dots, Y_T)\)</span>, suppose we are interested in looking for “change-points”, or times where the stochastic process changes. Often, we can tell that a process has changed, but we cannot discern exactly when it has changed because each observation <span class="math notranslate nohighlight">\(\{Y_t\}\)</span> is noisy. The following synthetic dataset gives one example of this:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[47]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Changepoint series with 5 data-points</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span>
<span class="n">T</span> <span class="o">=</span> <span class="mi">200</span>
<span class="n">_</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">beta</span> <span class="o">=</span> <span class="n">pyblip</span><span class="o">.</span><span class="n">utilities</span><span class="o">.</span><span class="n">generate_changepoint_data</span><span class="p">(</span>
    <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span> <span class="n">sparsity</span><span class="o">=</span><span class="mf">0.04</span><span class="p">,</span> <span class="n">coeff_size</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span> <span class="c1"># true mean of Y</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">T</span><span class="p">),</span> <span class="n">Y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Y&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Time&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Value&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="_images/usage_37_0.png" src="_images/usage_37_0.png" />
</div>
</div>
<p>To detect regions where the true mean of <span class="math notranslate nohighlight">\(Y\)</span> has changed, we can call the function <code class="docutils literal notranslate"><span class="pre">detect</span> <span class="pre">changepoints</span></code> which will fit a spike-and-slab changepoint model and apply BLiP on top of it. This only takes one line!</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[49]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">detections</span> <span class="o">=</span> <span class="n">pyblip</span><span class="o">.</span><span class="n">changepoint</span><span class="o">.</span><span class="n">detect_changepoints</span><span class="p">(</span>
    <span class="n">Y</span><span class="o">=</span><span class="n">Y</span><span class="p">,</span>
    <span class="n">q</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
    <span class="n">sample_kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span> <span class="n">chains</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">bsize</span><span class="o">=</span><span class="mi">5</span><span class="p">),</span> <span class="c1"># kwargs for the sampler</span>
    <span class="n">blip_kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">max_pep</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="c1"># kwargs for BLiP</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
BLiP ran in 11.71.
Long-step dual simplex will be used
</pre></div></div>
</div>
<p>Below, we plot these change-points on top of the raw data and the ground truth. Each output from BLiP is a region which contains a change point with high confidence. The detected regions are shaded in the plot: true detections are in green, and false detections are in orange.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[66]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Plot data-points and ground truth</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">T</span><span class="p">),</span> <span class="n">mu</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;E[Y]&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">T</span><span class="p">),</span> <span class="n">Y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Y&#39;</span><span class="p">)</span>

<span class="c1"># Add BLiP detections</span>
<span class="n">changepoints</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">beta</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
<span class="n">color_counts</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">orange</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">green</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># for legend</span>
<span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">cs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">detections</span><span class="p">):</span>
    <span class="n">cs</span> <span class="o">=</span> <span class="n">cs</span><span class="o">.</span><span class="n">group</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">changepoints</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">cs</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;green&#39;</span>
        <span class="n">cstring</span> <span class="o">=</span> <span class="s1">&#39;true positive&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;orange&#39;</span>
        <span class="n">cstring</span> <span class="o">=</span> <span class="s1">&#39;false positive&#39;</span>
    <span class="c1"># Decide whether to add a label</span>
    <span class="k">if</span> <span class="n">color_counts</span><span class="p">[</span><span class="n">color</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">color_counts</span><span class="p">[</span><span class="n">color</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">label</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;BLiP detection (</span><span class="si">{</span><span class="n">cstring</span><span class="si">}</span><span class="s1">)&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">label</span> <span class="o">=</span> <span class="kc">None</span>


    <span class="n">plt</span><span class="o">.</span><span class="n">axvspan</span><span class="p">(</span>
        <span class="nb">min</span><span class="p">(</span><span class="n">cs</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">cs</span><span class="p">),</span> <span class="n">alpha</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">cs</span><span class="p">)),</span>
        <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
        <span class="n">label</span><span class="o">=</span><span class="n">label</span>
    <span class="p">)</span>


<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Time&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Value&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<br/></pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="_images/usage_41_0.png" src="_images/usage_41_0.png" />
</div>
</div>
<p>As we can see, in this example, BLiP does a pretty good job both detecting change-points and quantifying our uncertainty in their locations. The vertical, thin green bars are change-points which have been perfectly localized.</p>
</div>
<div class="section" id="4.-Point-source-detection">
<h2>4. Point-source detection<a class="headerlink" href="#4.-Point-source-detection" title="Permalink to this headline"></a></h2>
<p>Suppose we observe photon counts from a telescope, and we are interested in detecting point-sources (e.g., stars) from the image. Since most images have some blur, we may not be able to perfectly localize each point-source, but BLiP can still help localize them as precisely as possible. Below, we give an example of how to apply BLiP on top of outputs from a pretrained <a class="reference external" href="https://github.com/Runjing-Liu120/DeblendingStarfields">StarNet model</a>. Note that the StarNet model is described in detail in
<a class="reference external" href="https://arxiv.org/pdf/2102.02409.pdf">Liu et. al (2021)</a>.</p>
<p>To start, we load the simulated <span class="math notranslate nohighlight">\(20x20\)</span> image data, which was generated using code from <a class="reference external" href="https://arxiv.org/pdf/2102.02409.pdf">Liu et. al (2021)</a>.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Load simulated image data</span>
<span class="n">npixels</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="s2">&quot;data/sim_image.txt&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">npixels</span><span class="p">,</span> <span class="n">npixels</span><span class="p">)</span>
<span class="n">true_locs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="s2">&quot;data/sim_locs.txt&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="c1"># plot one of the two bands</span>
<span class="k">def</span> <span class="nf">plot_starnet_sim</span><span class="p">():</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
    <span class="n">sns</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">image</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
        <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;Greys&#39;</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
        <span class="n">cbar_kws</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;log(Intensity)&#39;</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="c1"># Plot true locations</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
        <span class="n">npixels</span><span class="o">*</span><span class="n">true_locs</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">npixels</span><span class="o">*</span><span class="n">true_locs</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span>
        <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span>
        <span class="n">label</span><span class="o">=</span><span class="s1">&#39;True Sources&#39;</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plot_starnet_sim</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="_images/usage_46_0.png" src="_images/usage_46_0.png" />
</div>
</div>
<p>Next, we load the posterior samples from the pretrained StarNet model. See <a class="reference external" href="https://github.com/Runjing-Liu120/DeblendingStarfields">here</a> or <a class="reference external" href="https://github.com/amspector100/DeblendingStarfields%5D">here</a> for examples of how to fit pretrained StarNet models.</p>
<p>Note that the posterior samples are an <span class="math notranslate nohighlight">\((N, n_{\mathrm{source}}, d)\)</span>-shaped array, where <span class="math notranslate nohighlight">\(N\)</span> is the number of posterior samples and <span class="math notranslate nohighlight">\(d=2\)</span> is the dimension of the image. If <code class="docutils literal notranslate"><span class="pre">post_samples[i,</span> <span class="pre">j]</span> <span class="pre">=</span> <span class="pre">(x,</span> <span class="pre">y)</span></code>, this means that the <span class="math notranslate nohighlight">\(i\)</span>th posterior sample has asserted that there is a point-source at location <span class="math notranslate nohighlight">\((x,y)\)</span>. Since there may be different numbers of point-sources per iteration, NaNs are ignored. See API reference for more details on the data input format.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Load posterior samples from StarNet</span>
<span class="n">post_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="s1">&#39;data/post_samples.txt&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">996</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1"># Print the location of sources according to the first posterior sample.</span>
<span class="c1"># The NaN means there are only six estimated sources.</span>
<span class="n">post_samples</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
array([[0.07279399, 0.34460315],
       [0.05383444, 0.83722878],
       [0.12657177, 0.60644835],
       [0.54421228, 0.45192835],
       [0.76564646, 0.75837231],
       [0.87883556, 0.64780414],
       [       nan,        nan]])
</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># In contrast, in the 8th iteration, there were five estimated sources.</span>
<span class="n">post_samples</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
array([[0.07735128, 0.33859724],
       [0.04566601, 0.82996595],
       [0.19049473, 0.56281787],
       [0.59320527, 0.43181294],
       [0.87796324, 0.6558165 ],
       [       nan,        nan],
       [       nan,        nan]])
</pre></div></div>
</div>
<p>Given these posterior samples, applying BLiP is as easy as calling the <code class="docutils literal notranslate"><span class="pre">BLiP_cts</span></code> function. Note that <code class="docutils literal notranslate"><span class="pre">BLiP_cts</span></code> is useful in problems where the set of possible signal locations is continuous, for example in this problem, where a point-source could take any location in <span class="math notranslate nohighlight">\([0,20]^2\)</span>.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># the grid sizes determine the resolutions at which BLiP is applied</span>
<span class="n">grid_sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="mi">25</span><span class="p">)))</span>
<span class="n">detections</span> <span class="o">=</span> <span class="n">pyblip</span><span class="o">.</span><span class="n">blip</span><span class="o">.</span><span class="n">BLiP_cts</span><span class="p">(</span>
    <span class="n">post_samples</span><span class="p">,</span>
    <span class="n">error</span><span class="o">=</span><span class="s1">&#39;fdr&#39;</span><span class="p">,</span>
    <span class="n">q</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">rescale</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">grid_sizes</span><span class="o">=</span><span class="n">grid_sizes</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<p>We can plot these detections on top of the image to see the detections.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[43]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.patches</span> <span class="k">as</span> <span class="nn">patches</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plot_starnet_sim</span><span class="p">()</span>
<span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">detections</span><span class="p">):</span>
    <span class="n">center</span> <span class="o">=</span> <span class="n">npixels</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;center&#39;</span><span class="p">]</span>
     <span class="c1"># since rescale=False all radii are the same</span>
    <span class="n">radius</span> <span class="o">=</span> <span class="n">npixels</span><span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;radii&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;BLiP detection&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">label</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">circle</span> <span class="o">=</span> <span class="n">patches</span><span class="o">.</span><span class="n">Circle</span><span class="p">(</span>
        <span class="p">(</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
        <span class="n">radius</span><span class="p">,</span>
        <span class="n">edgecolor</span><span class="o">=</span><span class="p">(</span><span class="mi">30</span><span class="o">/</span><span class="mi">256</span><span class="p">,</span><span class="mi">144</span><span class="o">/</span><span class="mi">256</span><span class="p">,</span><span class="mi">255</span><span class="o">/</span><span class="mi">256</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span>
        <span class="n">facecolor</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="c1"># make interior transparent</span>
        <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">label</span><span class="o">=</span><span class="n">label</span>
    <span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">circle</span><span class="p">)</span>

<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="_images/usage_53_0.png" src="_images/usage_53_0.png" />
</div>
</div>
<p>As we can see, BLiP makes four true detections at various resolutions based on the posterior samples.</p>
</div>
<div class="section" id="5.-Inputs-for-arbitrary-problems">
<h2>5. Inputs for arbitrary problems<a class="headerlink" href="#5.-Inputs-for-arbitrary-problems" title="Permalink to this headline"></a></h2>
<p>So far, we have reviewed three major problem settings: variable selection, change-point detection, and point-source detection. However, in principle, BLiP can apply to any problem where one is interested in jointly detecting and localizing signals.</p>
<p>In generic problems, there are main types of inputs <code class="docutils literal notranslate"><span class="pre">BLiP</span></code> can take.</p>
<div class="section" id="5.1-Posterior-samples-for-discrete-problems">
<h3>5.1 Posterior samples for discrete problems<a class="headerlink" href="#5.1-Posterior-samples-for-discrete-problems" title="Permalink to this headline"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">pyblip.blip.BLiP</span></code> can take an <span class="math notranslate nohighlight">\((N,p)\)</span>-shaped matrix where nonzero values denote the presence of a signal variable. Here, <span class="math notranslate nohighlight">\(N\)</span> is the number of posterior samples and <span class="math notranslate nohighlight">\(p\)</span> is the number of locations at which a signal can exist. So if <code class="docutils literal notranslate"><span class="pre">samples[i,j]</span> <span class="pre">!=</span> <span class="pre">0</span></code>, this indicates that for in the <span class="math notranslate nohighlight">\(i\)</span>th posterior sample, the <span class="math notranslate nohighlight">\(j\)</span>th location contains a signal. We call these problems “discrete” because <span class="math notranslate nohighlight">\(p\)</span> is finite.</p>
</div>
<div class="section" id="5.2-Posterior-samples-for-continuous-problems">
<h3>5.2 Posterior samples for continuous problems<a class="headerlink" href="#5.2-Posterior-samples-for-continuous-problems" title="Permalink to this headline"></a></h3>
<p>In some problems, we may be searching for signals in <span class="math notranslate nohighlight">\(\mathbb{R}^d\)</span>. In this case, since there are an infinite number of possible locations for signals, we cannot automatically apply <code class="docutils literal notranslate"><span class="pre">pyblip.blip.BLiP</span></code>.</p>
<p>In this setting, <code class="docutils literal notranslate"><span class="pre">pyblip.blip.BLiP_cts</span></code> can posterior samples in a different format as an input. In particular, <code class="docutils literal notranslate"><span class="pre">pyblip.blip.BLiP_cts</span></code> assumes the posterior samples are an <span class="math notranslate nohighlight">\((N, n_{\mathrm{source}}, d)\)</span>-shaped array, where: 1. <span class="math notranslate nohighlight">\(N\)</span> is the number of posterior samples 2. <span class="math notranslate nohighlight">\(d\)</span> is the dimension of the data 3. If <code class="docutils literal notranslate"><span class="pre">samples[i,</span> <span class="pre">j]</span> <span class="pre">=</span> <span class="pre">(x1,</span> <span class="pre">...,</span> <span class="pre">xd)</span></code>, this means that the <span class="math notranslate nohighlight">\(i\)</span>th posterior sample has asserted that there is a point-source at location <span class="math notranslate nohighlight">\((x_1, \dots, x_d)\)</span>.
Since there may be different numbers of point-sources per iteration, NaNs are ignored.</p>
</div>
<div class="section" id="5.3-Advanced-usage:-directly-specifying-candidate-groups">
<h3>5.3 Advanced usage: directly specifying candidate groups<a class="headerlink" href="#5.3-Advanced-usage:-directly-specifying-candidate-groups" title="Permalink to this headline"></a></h3>
<p>A <code class="docutils literal notranslate"><span class="pre">CandidateGroup</span></code> object represents a subset of the locations which could potentially contain a signal. For example, in variable selection problems, each <code class="docutils literal notranslate"><span class="pre">CandidateGroup</span></code> represents a subset of the covariates. Alternatively, in the following example, each <code class="docutils literal notranslate"><span class="pre">CandidateGroup</span></code> represents three circular regions of the globe.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[82]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyblip.create_groups</span> <span class="kn">import</span> <span class="n">CandidateGroup</span>
<span class="n">cand_groups</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">CandidateGroup</span><span class="p">(</span>
        <span class="n">group</span><span class="o">=</span><span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,]),</span>
        <span class="n">pep</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
        <span class="n">data</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
            <span class="n">latitude</span><span class="o">=</span><span class="mf">41.0</span><span class="p">,</span>
            <span class="n">longitude</span><span class="o">=</span><span class="mf">74.0</span><span class="p">,</span>
            <span class="n">radius</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="s1">&#39;big_region&#39;</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">),</span>
    <span class="n">CandidateGroup</span><span class="p">(</span>
        <span class="n">group</span><span class="o">=</span><span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,]),</span>
        <span class="n">pep</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
        <span class="n">data</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
            <span class="n">latitude</span><span class="o">=</span><span class="mf">41.5</span><span class="p">,</span>
            <span class="n">longitude</span><span class="o">=</span><span class="mf">74.0</span><span class="p">,</span>
            <span class="n">radius</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="s1">&#39;sub_region1&#39;</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">),</span>
    <span class="n">CandidateGroup</span><span class="p">(</span>
        <span class="n">group</span><span class="o">=</span><span class="nb">set</span><span class="p">([</span><span class="mi">2</span><span class="p">,]),</span>
        <span class="n">pep</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
        <span class="n">data</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
            <span class="n">latitude</span><span class="o">=</span><span class="mf">40.5</span><span class="p">,</span>
            <span class="n">longitude</span><span class="o">=</span><span class="mf">74.0</span><span class="p">,</span>
            <span class="n">radius</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="s1">&#39;sub_region2&#39;</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">),</span>
<span class="p">]</span>
</pre></div>
</div>
</div>
<p>Each <code class="docutils literal notranslate"><span class="pre">CandidateGroup</span></code> has three attributes.</p>
<ol class="arabic simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">pep</span></code> attribute specifies the posterior error probability, or the posterior probability that the candidate group does <em>not</em> contain a signal.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">group</span></code> attribute is a set of positive integers such that two candidate groups overlap if and only if their <code class="docutils literal notranslate"><span class="pre">group</span></code> attributes overlap. For example, above, the group attributes suggest that the <code class="docutils literal notranslate"><span class="pre">big_region</span></code> overlaps with <code class="docutils literal notranslate"><span class="pre">sub_region1</span></code> and <code class="docutils literal notranslate"><span class="pre">sub_region2</span></code>, but <code class="docutils literal notranslate"><span class="pre">sub_region1</span></code> and <code class="docutils literal notranslate"><span class="pre">sub_region2</span></code> do not overlap.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">data</span></code> attribute is a optional dictionary that contains miscallaneous metadata. BLiP largely ignores the <code class="docutils literal notranslate"><span class="pre">data</span></code> attribute.</p></li>
</ol>
<p>One can directly apply BLiP on top of a list of candidate groups.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[94]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">detections</span> <span class="o">=</span> <span class="n">pyblip</span><span class="o">.</span><span class="n">blip</span><span class="o">.</span><span class="n">BLiP</span><span class="p">(</span>
    <span class="n">cand_groups</span><span class="o">=</span><span class="n">cand_groups</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">q</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
    <span class="n">error</span><span class="o">=</span><span class="s1">&#39;fdr&#39;</span><span class="p">,</span>
<span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">BLiP detected the candidate groups named: </span><span class="si">{</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">detections</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>

BLiP detected the candidate groups named: [&#39;big_region&#39;]
Long-step dual simplex will be used
</pre></div></div>
</div>
</div>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="installation.html" class="btn btn-neutral float-left" title="Getting Started" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="apiref.html" class="btn btn-neutral float-right" title="API Reference" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Asher Spector.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>